"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeAxisValue = computeAxisValue;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _d3Scale = require("@mui/x-charts-vendor/d3-scale");
var _axis = require("../../../../models/axis");
var _colorScale = require("../../../colorScale");
var _ticks = require("../../../ticks");
var _getScale = require("../../../getScale");
var _dateHelpers = require("../../../dateHelpers");
var _getAxisExtremum = require("./getAxisExtremum");
var _angleConversion = require("../../../angleConversion");
var _getAxisTriggerTooltip = require("./getAxisTriggerTooltip");
function getRange(drawingArea, axisDirection, axis) {
  if (axisDirection === 'rotation') {
    if (axis.scaleType === 'point') {
      const angles = [(0, _angleConversion.deg2rad)(axis.startAngle, 0), (0, _angleConversion.deg2rad)(axis.endAngle, 2 * Math.PI)];
      const diff = angles[1] - angles[0];
      if (diff > Math.PI * 2 - 0.1) {
        // If we cover a full circle, we remove a slice to avoid having data point at the same place.
        angles[1] -= diff / axis.data.length;
      }
      return angles;
    }
    return [(0, _angleConversion.deg2rad)(axis.startAngle, 0), (0, _angleConversion.deg2rad)(axis.endAngle, 2 * Math.PI)];
  }
  return [0, Math.min(drawingArea.height, drawingArea.width) / 2];
}
const DEFAULT_CATEGORY_GAP_RATIO = 0.2;
const DEFAULT_BAR_GAP_RATIO = 0.1;
function computeAxisValue({
  drawingArea,
  formattedSeries,
  axis: allAxis,
  seriesConfig,
  axisDirection
}) {
  if (allAxis === undefined) {
    return {
      axis: {},
      axisIds: []
    };
  }
  const axisIdsTriggeringTooltip = (0, _getAxisTriggerTooltip.getAxisTriggerTooltip)(axisDirection, seriesConfig, formattedSeries, allAxis[0].id);
  const completeAxis = {};
  allAxis.forEach((eachAxis, axisIndex) => {
    const axis = eachAxis;
    const range = getRange(drawingArea, axisDirection, axis);
    const [minData, maxData] = (0, _getAxisExtremum.getAxisExtremum)(axis, axisDirection, seriesConfig, axisIndex, formattedSeries);
    const triggerTooltip = !axis.ignoreTooltip && axisIdsTriggeringTooltip.has(axis.id);
    const data = axis.data ?? [];
    if ((0, _axis.isBandScaleConfig)(axis)) {
      const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;
      const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;
      completeAxis[axis.id] = (0, _extends2.default)({
        offset: 0,
        categoryGapRatio,
        barGapRatio,
        triggerTooltip
      }, axis, {
        data,
        scale: (0, _d3Scale.scaleBand)(axis.data, range).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? (0, _colorScale.getOrdinalColorScale)((0, _extends2.default)({
          values: axis.data
        }, axis.colorMap)) : (0, _colorScale.getColorScale)(axis.colorMap))
      });
      if ((0, _dateHelpers.isDateData)(axis.data)) {
        const dateFormatter = (0, _dateHelpers.createDateFormatter)(axis, range);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if ((0, _axis.isPointScaleConfig)(axis)) {
      completeAxis[axis.id] = (0, _extends2.default)({
        offset: 0,
        triggerTooltip
      }, axis, {
        data,
        scale: (0, _d3Scale.scalePoint)(axis.data, range),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? (0, _colorScale.getOrdinalColorScale)((0, _extends2.default)({
          values: axis.data
        }, axis.colorMap)) : (0, _colorScale.getColorScale)(axis.colorMap))
      });
      if ((0, _dateHelpers.isDateData)(axis.data)) {
        const dateFormatter = (0, _dateHelpers.createDateFormatter)(axis, range);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (axis.scaleType === 'band' || axis.scaleType === 'point') {
      // Could be merged with the two previous "if conditions" but then TS does not get that `axis.scaleType` can't be `band` or `point`.
      return;
    }
    const scaleType = axis.scaleType ?? 'linear';
    const domainLimit = axis.domainLimit ?? 'nice';
    const axisExtremums = [axis.min ?? minData, axis.max ?? maxData];
    if (typeof domainLimit === 'function') {
      const {
        min,
        max
      } = domainLimit(minData, maxData);
      axisExtremums[0] = min;
      axisExtremums[1] = max;
    }
    const rawTickNumber = (0, _ticks.getTickNumber)((0, _extends2.default)({}, axis, {
      range,
      domain: axisExtremums
    }));
    const tickNumber = (0, _ticks.scaleTickNumberByRange)(rawTickNumber, range);
    const scale = (0, _getScale.getScale)(scaleType, axisExtremums, range);
    const finalScale = domainLimit === 'nice' ? scale.nice(rawTickNumber) : scale;
    const [minDomain, maxDomain] = finalScale.domain();
    const domain = [axis.min ?? minDomain, axis.max ?? maxDomain];
    completeAxis[axis.id] = (0, _extends2.default)({
      offset: 0,
      triggerTooltip
    }, axis, {
      data,
      scaleType: scaleType,
      scale: finalScale.domain(domain),
      tickNumber,
      colorScale: axis.colorMap && (0, _colorScale.getColorScale)(axis.colorMap)
    });
  });
  return {
    axis: completeAxis,
    axisIds: allAxis.map(({
      id
    }) => id)
  };
}