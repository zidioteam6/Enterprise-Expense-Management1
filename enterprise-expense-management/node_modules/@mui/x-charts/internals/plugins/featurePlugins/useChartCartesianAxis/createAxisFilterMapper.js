"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAxisFilterMapper = createAxisFilterMapper;
exports.createGetAxisFilters = void 0;
var _isDefined = require("../../../isDefined");
var _getAxisExtremum = require("./getAxisExtremum");
var _getScale = require("../../../getScale");
function createAxisFilterMapper({
  zoomMap,
  zoomOptions,
  seriesConfig,
  formattedSeries,
  direction
}) {
  return (axis, axisIndex) => {
    const zoomOption = zoomOptions[axis.id];
    if (!zoomOption || zoomOption.filterMode !== 'discard') {
      return null;
    }
    const zoom = zoomMap?.get(axis.id);
    if (zoom === undefined || zoom.start <= 0 && zoom.end >= 100) {
      // No zoom, or zoom with all data visible
      return null;
    }
    let extremums = [];
    const scaleType = axis.scaleType;
    if (scaleType === 'point' || scaleType === 'band') {
      extremums = [0, (axis.data?.length ?? 1) - 1];
    } else {
      extremums = (0, _getAxisExtremum.getAxisExtremum)(axis, direction, seriesConfig, axisIndex, formattedSeries);
    }
    let min;
    let max;
    const continuousScaleType = !scaleType || scaleType === 'band' || scaleType === 'point' ? 'linear' : scaleType;
    [min, max] = (0, _getScale.getScale)(continuousScaleType, extremums, [0, 100]).nice().domain();
    min = min instanceof Date ? min.getTime() : min;
    max = max instanceof Date ? max.getTime() : max;
    const minVal = min + zoom.start * (max - min) / 100;
    const maxVal = min + zoom.end * (max - min) / 100;
    return (value, dataIndex) => {
      const val = value[direction] ?? axis.data?.[dataIndex];
      if (val == null) {
        // If the value does not exist because of missing data point, or out of range index, we just ignore.
        return true;
      }
      if (axis.scaleType === 'point' || axis.scaleType === 'band' || typeof val === 'string') {
        return dataIndex >= minVal && dataIndex <= maxVal;
      }
      return val >= minVal && val <= maxVal;
    };
  };
}
const createGetAxisFilters = filters => ({
  currentAxisId,
  seriesXAxisId,
  seriesYAxisId,
  isDefaultAxis
}) => {
  return (value, dataIndex) => {
    const axisId = currentAxisId === seriesXAxisId ? seriesYAxisId : seriesXAxisId;
    if (!axisId || isDefaultAxis) {
      return Object.values(filters ?? {})[0]?.(value, dataIndex) ?? true;
    }
    const data = [seriesYAxisId, seriesXAxisId].filter(id => id !== currentAxisId).map(id => filters[id ?? '']).filter(_isDefined.isDefined);
    return data.every(f => f(value, dataIndex));
  };
};
exports.createGetAxisFilters = createGetAxisFilters;