"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectorChartZoomOptionsLookup = exports.selectorChartZoomMap = exports.selectorChartZoomIsInteracting = exports.selectorChartYAxis = exports.selectorChartXAxis = exports.selectorChartRawAxis = exports.selectorChartAxisZoomOptionsLookup = exports.createZoomMap = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _useChartDimensions = require("../../corePlugins/useChartDimensions");
var _useChartSeries = require("../../corePlugins/useChartSeries");
var _selectors = require("../../utils/selectors");
var _computeAxisValue = require("./computeAxisValue");
var _createAxisFilterMapper = require("./createAxisFilterMapper");
var _createZoomLookup = require("./createZoomLookup");
var _useChartCartesianAxisLayout = require("./useChartCartesianAxisLayout.selectors");
const createZoomMap = zoom => {
  const zoomItemMap = new Map();
  zoom.forEach(zoomItem => {
    zoomItemMap.set(zoomItem.axisId, zoomItem);
  });
  return zoomItemMap;
};
exports.createZoomMap = createZoomMap;
const selectorChartZoomState = state => state.zoom;

/**
 * Following selectors are not exported because they exist in the MIT chart only to ba able to reuse the Zoom state from the pro.
 */

const selectorChartZoomIsInteracting = exports.selectorChartZoomIsInteracting = (0, _selectors.createSelector)(selectorChartZoomState, zoom => zoom?.isInteracting);
const selectorChartZoomMap = exports.selectorChartZoomMap = (0, _selectors.createSelector)(selectorChartZoomState, zoom => zoom?.zoomData && createZoomMap(zoom?.zoomData));
const selectorChartXZoomOptionsLookup = (0, _selectors.createSelector)(_useChartCartesianAxisLayout.selectorChartRawXAxis, (0, _createZoomLookup.createZoomLookup)('x'));
const selectorChartYZoomOptionsLookup = (0, _selectors.createSelector)(_useChartCartesianAxisLayout.selectorChartRawYAxis, (0, _createZoomLookup.createZoomLookup)('y'));
const selectorChartZoomOptionsLookup = exports.selectorChartZoomOptionsLookup = (0, _selectors.createSelector)([selectorChartXZoomOptionsLookup, selectorChartYZoomOptionsLookup], (xLookup, yLookup) => (0, _extends2.default)({}, xLookup, yLookup));
const selectorChartAxisZoomOptionsLookup = exports.selectorChartAxisZoomOptionsLookup = (0, _selectors.createSelector)([selectorChartXZoomOptionsLookup, selectorChartYZoomOptionsLookup, (state, axisId) => axisId], (xLookup, yLookup, axisId) => xLookup[axisId] ?? yLookup[axisId]);
const selectorChartXFilter = (0, _selectors.createSelector)([selectorChartZoomMap, selectorChartZoomOptionsLookup, _useChartSeries.selectorChartSeriesConfig, _useChartSeries.selectorChartSeriesProcessed], (zoomMap, zoomOptions, seriesConfig, formattedSeries) => zoomMap && zoomOptions && (0, _createAxisFilterMapper.createAxisFilterMapper)({
  zoomMap,
  zoomOptions,
  seriesConfig,
  formattedSeries,
  direction: 'x'
}));
const selectorChartYFilter = (0, _selectors.createSelector)([selectorChartZoomMap, selectorChartZoomOptionsLookup, _useChartSeries.selectorChartSeriesConfig, _useChartSeries.selectorChartSeriesProcessed], (zoomMap, zoomOptions, seriesConfig, formattedSeries) => zoomMap && zoomOptions && (0, _createAxisFilterMapper.createAxisFilterMapper)({
  zoomMap,
  zoomOptions,
  seriesConfig,
  formattedSeries,
  direction: 'y'
}));
const selectorChartZoomAxisFilters = (0, _selectors.createSelector)([selectorChartXFilter, selectorChartYFilter, _useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartCartesianAxisLayout.selectorChartRawYAxis], (xMapper, yMapper, xAxis, yAxis) => {
  if (xMapper === undefined || yMapper === undefined) {
    // Early return if there is no zoom.
    return undefined;
  }
  const xFilters = xAxis?.reduce((acc, axis, index) => {
    const filter = xMapper(axis, index);
    if (filter !== null) {
      acc[axis.id] = filter;
    }
    return acc;
  }, {});
  const yFilters = yAxis?.reduce((acc, axis, index) => {
    const filter = yMapper(axis, index);
    if (filter !== null) {
      acc[axis.id] = filter;
    }
    return acc;
  }, {});
  if (Object.keys(xFilters ?? {}).length === 0 && Object.keys(yFilters ?? {}).length === 0) {
    return undefined;
  }
  return (0, _createAxisFilterMapper.createGetAxisFilters)((0, _extends2.default)({}, xFilters, yFilters));
});

/**
 * The only interesting selectors that merge axis data and zoom if provided.
 */

const selectorChartXAxis = exports.selectorChartXAxis = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartDimensions.selectorChartDrawingArea, _useChartSeries.selectorChartSeriesProcessed, _useChartSeries.selectorChartSeriesConfig, selectorChartZoomMap, selectorChartZoomOptionsLookup, selectorChartZoomAxisFilters], (axis, drawingArea, formattedSeries, seriesConfig, zoomMap, zoomOptions, getFilters) => (0, _computeAxisValue.computeAxisValue)({
  drawingArea,
  formattedSeries,
  axis,
  seriesConfig,
  axisDirection: 'x',
  zoomMap,
  zoomOptions,
  getFilters
}));
const selectorChartYAxis = exports.selectorChartYAxis = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawYAxis, _useChartDimensions.selectorChartDrawingArea, _useChartSeries.selectorChartSeriesProcessed, _useChartSeries.selectorChartSeriesConfig, selectorChartZoomMap, selectorChartZoomOptionsLookup, selectorChartZoomAxisFilters], (axis, drawingArea, formattedSeries, seriesConfig, zoomMap, zoomOptions, getFilters) => (0, _computeAxisValue.computeAxisValue)({
  drawingArea,
  formattedSeries,
  axis,
  seriesConfig,
  axisDirection: 'y',
  zoomMap,
  zoomOptions,
  getFilters
}));
const selectorChartRawAxis = exports.selectorChartRawAxis = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartCartesianAxisLayout.selectorChartRawYAxis, (state, axisId) => axisId], (xAxes, yAxes, axisId) => {
  const axis = xAxes?.find(a => a.id === axisId) ?? yAxes?.find(a => a.id === axisId) ?? null;
  if (!axis) {
    return undefined;
  }
  return axis;
});