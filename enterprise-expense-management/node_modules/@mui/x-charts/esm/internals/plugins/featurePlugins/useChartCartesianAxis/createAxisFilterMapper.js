import { isDefined } from "../../../isDefined.js";
import { getAxisExtremum } from "./getAxisExtremum.js";
import { getScale } from "../../../getScale.js";
export function createAxisFilterMapper({
  zoomMap,
  zoomOptions,
  seriesConfig,
  formattedSeries,
  direction
}) {
  return (axis, axisIndex) => {
    const zoomOption = zoomOptions[axis.id];
    if (!zoomOption || zoomOption.filterMode !== 'discard') {
      return null;
    }
    const zoom = zoomMap?.get(axis.id);
    if (zoom === undefined || zoom.start <= 0 && zoom.end >= 100) {
      // No zoom, or zoom with all data visible
      return null;
    }
    let extremums = [];
    const scaleType = axis.scaleType;
    if (scaleType === 'point' || scaleType === 'band') {
      extremums = [0, (axis.data?.length ?? 1) - 1];
    } else {
      extremums = getAxisExtremum(axis, direction, seriesConfig, axisIndex, formattedSeries);
    }
    let min;
    let max;
    const continuousScaleType = !scaleType || scaleType === 'band' || scaleType === 'point' ? 'linear' : scaleType;
    [min, max] = getScale(continuousScaleType, extremums, [0, 100]).nice().domain();
    min = min instanceof Date ? min.getTime() : min;
    max = max instanceof Date ? max.getTime() : max;
    const minVal = min + zoom.start * (max - min) / 100;
    const maxVal = min + zoom.end * (max - min) / 100;
    return (value, dataIndex) => {
      const val = value[direction] ?? axis.data?.[dataIndex];
      if (val == null) {
        // If the value does not exist because of missing data point, or out of range index, we just ignore.
        return true;
      }
      if (axis.scaleType === 'point' || axis.scaleType === 'band' || typeof val === 'string') {
        return dataIndex >= minVal && dataIndex <= maxVal;
      }
      return val >= minVal && val <= maxVal;
    };
  };
}
export const createGetAxisFilters = filters => ({
  currentAxisId,
  seriesXAxisId,
  seriesYAxisId,
  isDefaultAxis
}) => {
  return (value, dataIndex) => {
    const axisId = currentAxisId === seriesXAxisId ? seriesYAxisId : seriesXAxisId;
    if (!axisId || isDefaultAxis) {
      return Object.values(filters ?? {})[0]?.(value, dataIndex) ?? true;
    }
    const data = [seriesYAxisId, seriesXAxisId].filter(id => id !== currentAxisId).map(id => filters[id ?? '']).filter(isDefined);
    return data.every(f => f(value, dataIndex));
  };
};